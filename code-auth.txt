

================= FILE: pages/login.vue =================

// pages/login.vue - V1.3 - Mapeamento robusto da resposta da API e tratamento de erro aprimorado
<template>
<div class="min-h-screen flex flex-col">
 <header class="flex justify-between items-center p-4 shadow-md bg-white">
 <h1 class="text-xl font-bold text-gray-800">Login</h1>
 </header>

 <div class="flex flex-grow justify-center items-center p-4 bg-gray-50">
 <ClientOnly>
  <div class="w-full max-w-md form-card login-card p-8 bg-white rounded-xl shadow-2xl">
  <h2 class="text-2xl font-bold text-center mb-6 text-gray-800">Acesse sua conta</h2>
  
  <form @submit.prevent="handleLogin" class="space-y-4">
   <div>
   <label for="username" class="block text-sm font-medium text-gray-700">Nome de Usu√°rio</label>
   <input
    type="text"
    id="username"
    v-model="credentials.username"
    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2"
    required
   />
   </div>

   <div>
   <label for="password" class="block text-sm font-medium text-gray-700">Senha</label>
   <input
    type="password"
    id="password"
    v-model="credentials.password"
    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2"
    required
   />
   </div>
   
   <div v-if="error" class="text-red-600 text-sm p-2 bg-red-100 rounded">
   {{ error }}
   </div>

   <div class="pt-4">
   <button
    type="submit"
    :disabled="isLoading"
    class="w-full py-3 bg-btn-secundario text-btn-font-secundario rounded-md font-bold hover:opacity-80 disabled:bg-btn-desativado disabled:text-btn-font-desativado transition duration-150"
   >
    {{ isLoading ? 'Entrando...' : 'Entrar' }}
   </button>
   </div>
  </form>
  </div>
  <template #fallback>
  <div class="text-center p-8">Carregando formul√°rio de login...</div>
  </template>
 </ClientOnly>
 </div>
</div>
</template>

<script setup>
import { reactive, ref } from 'vue';
import { useAuthStore } from '~/stores/auth';

definePageMeta({
layout: false 
});

const authStore = useAuthStore();
const credentials = reactive({
username: '',
password: ''
});
const isLoading = ref(false);
const error = ref(null);

const handleLogin = async () => {
error.value = null;
isLoading.value = true;

try {
  // 1. Obt√©m o valor completo do campo (ex: 'Patricia Santos')
  const fullName = credentials.username.trim(); 
  
  // 2. Extrai APENAS o primeiro nome, preservando o case e a acentua√ß√£o.
  const firstName = fullName.split(' ')[0];

  // 3. Cria o payload de login com o primeiro nome extra√≠do
  const loginPayloadToSend = {
    username: firstName,
    password: credentials.password
  };

 const apiResponse = await $fetch('/api/auth', { 
 method: 'POST', 
 body: loginPayloadToSend,
 headers: { 'Content-Type': 'application/json' }
 });
    
  // üö® NOVO: Checagem Cr√≠tica do Token e userId
  if (!apiResponse || !apiResponse.token || !apiResponse.userId) {
    // Lan√ßa um erro espec√≠fico que podemos tratar abaixo
    throw new Error('AUTH_PAYLOAD_INVALID: Token ou ID de usu√°rio ausente na resposta da API.');
  }

 // Mapeia os campos necess√°rios da resposta da API de forma resiliente
 const userPayload = {
 id: apiResponse.userId, // ‚úÖ Padroniza√ß√£o: 'id' principal e compatibilidade
 userId: apiResponse.userId,
 username: apiResponse.username,
 apelido: apiResponse.apelido || apiResponse.username,
 heightCm: apiResponse.heightCm, 
 initialWeight: apiResponse.initialWeight || 90.0,
 email: apiResponse.email || '', 
 role: apiResponse.role || 'user', 
 photo_perfil_url: apiResponse.photo_perfil_url || '' 
 };
 
 const authPayload = {
 token: apiResponse.token, 
 user: userPayload
 };

 // Chama o login, que persistir√° os dados e definir√° isAuthenticated = true
 authStore.login(authPayload); 
 await navigateTo('/', { replace: true });

} catch (e) {
 const status = e.response?.status;
 const message = e.response?._data?.message;

 if (status === 401 || status === 403) {
 error.value = message || 'Nome de usu√°rio ou senha incorretos.';
 } else if (e.message && e.message.includes('AUTH_PAYLOAD_INVALID')) {
    // Trata o erro espec√≠fico de payload ausente
    error.value = 'Resposta de login incompleta. Contate o administrador do sistema.';
  } else {
 error.value = 'Falha na comunica√ß√£o com o servidor. Verifique se o backend est√° online.';
    console.error('Erro durante o login:', e);
 }
} finally {
 isLoading.value = false;
}
};
</script>

<style scoped>
.form-card {
box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
}
</style>

================= FILE: stores/auth.ts =================

// ~/stores/auth.ts - V1.7 - Suporte a Owner e persist√™ncia robusta
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

type AnyUser = Record<string, any>

export const useAuthStore = defineStore('auth', () => {
  const user = ref<AnyUser | null>(null)
  const token = ref<string | null>(null)
  const isAuthenticated = ref(false)
  const initialized = ref(false)

  // --- Roles ---
  const isAdmin = computed(() => String(user.value?.role || '').toLowerCase() === 'admin')
  const isOwner = computed(() => String(user.value?.role || '').toLowerCase() === 'owner')

  // --- Login ---
  const login = (data: { token?: string; user: AnyUser }) => {
    token.value = data.token || null
    const incoming = data.user || {}

    const normalizedUser: AnyUser = {
      ...incoming,
      id: incoming.id ?? incoming.userId ?? incoming.id,
    }
    normalizedUser.userId = incoming.userId ?? incoming.id ?? normalizedUser.userId
    user.value = normalizedUser
    isAuthenticated.value = true

    if (process.client) {
      if (token.value) localStorage.setItem('authToken', token.value)
      localStorage.setItem('authUser', JSON.stringify(user.value))
    }

    initialized.value = true
  }

  // --- Logout ---
  const logout = () => {
    token.value = null
    user.value = null
    isAuthenticated.value = false
    initialized.value = true

    if (process.client) {
      localStorage.removeItem('authToken')
      localStorage.removeItem('authUser')
    }
  }

  const clearAuthData = () => logout()

  // --- Init (S√≠ncrono) ---
  const init = () => {
    if (initialized.value) return
    if (!process.client) {
      initialized.value = true
      return
    }

    try {
      const savedToken = localStorage.getItem('authToken')
      const savedUser = localStorage.getItem('authUser')

      if (savedToken && savedUser) {
        token.value = savedToken
        const parsed = JSON.parse(savedUser)
        const normalizedUser: AnyUser = {
          ...parsed,
          id: parsed.id ?? parsed.userId ?? parsed.id,
        }
        normalizedUser.userId = parsed.userId ?? parsed.id ?? normalizedUser.userId
        user.value = normalizedUser
        isAuthenticated.value = true
      } else {
        token.value = null
        user.value = null
        isAuthenticated.value = false
      }
    } catch (err) {
      console.error('auth.init: erro inesperado', err)
      token.value = null
      user.value = null
      isAuthenticated.value = false
    } finally {
      initialized.value = true
    }
  }

  return {
    user,
    token,
    isAuthenticated,
    initialized,
    isAdmin,
    isOwner,
    login,
    logout,
    clearAuthData,
    init,
  }
})


================= FILE: server/api/auth.post.ts =================

// /server/api/auth.post.ts - V1.3 - Grava√ß√£o da data de √∫ltimo login
import { defineEventHandler, readBody, createError } from 'h3';
import { prisma } from '~/server/utils/db';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

export default defineEventHandler(async (event) => {
 try {
  const { username, password } = await readBody(event);

  if (!username || !password) {
   throw createError({ statusCode: 400, statusMessage: 'Nome de usu√°rio e senha s√£o obrigat√≥rios.' });
  }

  // Busca pelo primeiro nome (ignora sobrenomes e case)
  const user = await prisma.users.findFirst({
   where: {
    username: {
     startsWith: username,
     mode: 'insensitive',
    },
   },
  });

  if (!user) {
   throw createError({ statusCode: 401, statusMessage: 'Credenciais inv√°lidas.' });
  }

  const isMatch = await bcrypt.compare(password, user.password_hash);
  if (!isMatch) {
   throw createError({ statusCode: 401, statusMessage: 'Credenciais inv√°lidas.' });
  }

    // -------------------------------------------------------------------
    // A√á√ÉO CR√çTICA: ATUALIZA√á√ÉO DO CAMPO LAST_LOGIN
    // -------------------------------------------------------------------
    await prisma.users.update({
        where: { id: user.id },
        data: {
            // new Date() armazena o timestamp atual
            last_login: new Date(), 
        },
    });
    // -------------------------------------------------------------------

  const token = jwt.sign(
   { userId: user.id, role: user.role },
   process.env.JWT_SECRET || 'fallback_secret_NAO_USAR_EM_PRODUCAO',
   { expiresIn: '1d' }
  );

  return {
   token,
   userId: user.id,
   username: user.username,
   email: user.email,
   role: user.role,
   apelido: user.apelido,
   photo_perfil_url: user.photo_perfil_url,
   heightCm: user.height_cm,
   initialWeight: user.initial_weight_kg,
  };
 } catch (error) {
  if (error.statusCode) throw error;
  console.error('Erro de autentica√ß√£o:', error);
  throw createError({ statusCode: 500, statusMessage: 'Erro interno do servidor.' });
 }
});